library(plumber)
library(jsonlite)
library(glue)
library(uuid)
library(fs)
library(rmarkdown)
library(base64enc)
library(qrcode)
library(knitr)

# Plumber API definieren
pr <- Plumber$new()

# TODO: Discuss this with Denis
# Sys.getenv("RSTUDIO_PANDOC")
Sys.setenv(RSTUDIO_PANDOC="C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools")

# CORS-Filter hinzufügen
pr$filter("cors", function(req, res) {
  res$setHeader("Access-Control-Allow-Origin", "*")
  res$setHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
  res$setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization")
  if (req$REQUEST_METHOD == "OPTIONS") {
    res$status <- 200
    return(list())
  } else {
    forward()
  }
})



# /generate-certificate Endpoint (POST)
pr$handle("POST", "/generate-certificate", function(req, res){
  tryCatch({
    # JSON-Daten parsen
    body <- fromJSON(req$postBody, simplifyVector = FALSE)
    
    # Validierung der erforderlichen Felder
    if (is.null(body$certificate) || is.null(body$image) || is.null(body$generation)) {
      res$status <- 400
      return(list(error = "Fehlende erforderliche Felder"))
    }
    
    # Eindeutige ID generieren
    id <- UUIDgenerate()
    
    # Temporäre Dateien erstellen
    temp_pdf <- sprintf("certificate_%s.pdf", id)
    
    certificate_template_path <- "certificate_template.Rmd"

    temp_images_folder <- "temp_images"

    if (!dir.exists(temp_images_folder)) {
      dir.create(temp_images_folder)
    }

    # PDF generieren mit detailliertem Logging
    cat("Starting PDF generation...\n")
    render_result <- tryCatch({
      rmarkdown::render(
        certificate_template_path,
        output_file = temp_pdf,
        quiet = FALSE,  # Zeige Logs
        params = list(
          certificate = body$certificate,
          imageBase64 = body$image$base64Data,
          metadata = body$metadata,
          generation = body$generation
        )
      )
    }, error = function(e) {
      cat("Error during PDF rendering:", e$message, "\n")
      stop(e)
    })
    
    cat("PDF generation completed. File:", temp_pdf, "\n")
    
    # Prüfen ob PDF existiert
    if (!file.exists(temp_pdf)) {
      stop("PDF file was not created")
    }
    
    # PDF-Daten lesen
    pdf_data <- readBin(temp_pdf, what = "raw", n = file.info(temp_pdf)$size)
    cat("PDF data read, size:", length(pdf_data), "bytes\n")
    
    # Temporäre Dateien löschen
    file_delete(temp_pdf)

    # Delete temporary images generated by the certificate code
    unlink(file.path(temp_images_folder, "*"), recursive = TRUE)

    cat("Temporary files cleaned up\n")
    
    # Response senden
    res$setHeader("Content-Type", "application/pdf")
    res$setHeader("Content-Disposition", sprintf("attachment; filename=\"baum_zertifikat_%s.pdf\"", id))
    return(pdf_data)
    
  }, error = function(e) {
    # Fehlerbehandlung
    cat("Error in generate-certificate endpoint:", e$message, "\n")
    res$status <- 500
    return(list(error = paste("Fehler bei der PDF-Generierung:", e$message)))
  })
})

# Health Check Endpoint
pr$handle("GET", "/health", function(req, res) {
  return(list(status = "OK", message = "R-Backend läuft"))
})

# API starten
cat("Starting R-Backend API on port 8000...\n")
pr$run(host = "0.0.0.0", port = 8000)
